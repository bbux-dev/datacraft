{
  "types": [
    {
      "type_name": "values",
      "params": [
        {
          "name": "data",
          "type": "Union[int, float, str, bool, List, Dict[str, float]]",
          "description": "to use to supply values"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "combine",
      "params": [
        {
          "name": "refs",
          "type": "List[Union[str, FieldInfo]] = None",
          "description": "refs to combine"
        },
        {
          "name": "fields",
          "type": "List[Union[str, FieldInfo]] = None",
          "description": "fields to combine"
        }
      ],
      "custom_logic": "    if refs is not None:\n        spec['refs'] = _create_key_list(refs)\n    if fields is not None:\n        spec['fields'] = _create_key_list(fields)"
    },
    {
      "type_name": "combine-list",
      "params": [
        {
          "name": "refs",
          "type": "List[Union[List[str], List[FieldInfo]]] = None",
          "description": "lists of lists of refs to combine"
        }
      ],
      "custom_logic": "    if refs is None:\n        refs = []",
      "spec_params": [{"name": "refs", "value": "[_create_key_list(ref_list) for ref_list in refs]"}]
    },
    {
      "type_name": "range",
      "params": [
        {
          "name": "data",
          "type": "list",
          "description": "with start, end, and optional step"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "rand_range",
      "params": [
        {
          "name": "data",
          "type": "list",
          "description": "with start and end of ranges"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "date"
    },
    {
      "type_name": "date.iso"
    },
    {
      "type_name": "date.iso.us"
    },
    {
      "type_name": "uuid"
    },
    {
      "type_name": "char_class",
      "params": [
        {
          "name": "data",
          "type": "Union[str, List[str]]",
          "description": "either known character class or set of characters to use for sampling from"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "char_class_abbrev",
      "params": [
        {
          "name": "cc_abbrev",
          "type": "str",
          "description": "alternative type abbreviation i.e. ascii, cc-ascii, visible, cc-visible"
        }
      ],
      "custom_logic": "    if cc_abbrev.startswith('cc-'):\n        spec['type'] = cc_abbrev\n    else:\n        spec['type'] = 'cc-' + cc_abbrev"
    },
    {
      "type_name": "unicode_range",
      "params": [
        {
          "name": "data",
          "type": "Union[List[str], List[List[str]]]",
          "description": "hex start and end unicode ranges or lists of these"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "geo.lat"
    },
    {
      "type_name": "geo.long"
    },
    {
      "type_name": "geo.pair"
    },
    {
      "type_name": "ip"
    },
    {
      "type_name": "ipv4"
    },
    {
      "type_name": "ip.precise"
    },
    {
      "type_name": "weighted_ref",
      "params": [
        {
          "name": "data",
          "type": "Dict[str, float]",
          "description": "Mapping of ref name to weight"
        }
      ],
      "spec_params": [{"name": "data", "value": "data"}]
    },
    {
      "type_name": "select_list_subset",
      "params": [
        {
          "name": "data",
          "type": "List[Any] = None",
          "description": "to select from"
        },
        {
          "name": "ref",
          "type": "str = None",
          "description": "that contains data to select from"
        }
      ],
      "custom_logic": "    if data is not None:\n        spec['data'] = data\n    if ref is not None:\n        spec['ref'] = ref"
    },
    {
      "type_name": "csv"
    },
    {
      "type_name": "csv_select",
      "params": [
        {
          "name": "data",
          "type": "Dict[str, int] = None",
          "description": "Mapping of field name to one based column number"
        }
      ],
      "custom_logic": "    if data is not None:\n        spec['data'] = data"
    },
    {
      "type_name": "nested",
      "params": [
        {
          "name": "fields",
          "type": "Union[Dict[str, Dict], DataSpec]",
          "description": "sub field specifications"
        }
      ],
      "spec_params": [{"name": "fields", "value": "utils.get_raw_spec(fields)"}]
    },
    {
      "type_name": "config_ref",
      "custom_builder_logic": "    # this must be a refs instance\n        if self.refs_builder is None:\n            return self.add_field(key, config_ref(**config))\n        else:\n            return self.add_ref(key, config_ref(**config))"
    },
    {
      "type_name": "calculate",
      "params": [
        {
          "name": "refs",
          "type": "dict = None",
          "description": "mapping of ref to alias to used in formula"
        },
        {
          "name": "fields",
          "type": "dict = None",
          "description": "mapping of field name to alias used in formula"
        },
        {
          "name": "formula",
          "type": "str = None",
          "description": "formula to execute against results of refs/fields"
        }
      ],
      "spec_params": [{"name": "formula", "value": "formula"}],
      "custom_logic": "    if refs is not None:\n        spec['refs'] = refs\n    if fields is not None:\n        spec['fields'] = fields"
    },
    {
      "type_name": "ref",
      "params": [
        {
          "name": "ref_name",
          "type": "str = None",
          "description": "name of reference to get values from"
        },
        {
          "name": "data",
          "type": "str = None",
          "description": "name of reference to get values from"
        }
      ],
      "custom_logic": "    if data is not None:\n        spec['data'] = data\n    if ref_name is not None:\n        spec['ref'] = ref_name"
    },
    {
      "type_name": "weighted_csv"
    }
  ]
}
